// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
#include "Component_Body.h"
#include "Component_Shape.h"
#include "MathUtils.h"
#include "System_PhysicsBall.h"


///-------------------------------------------------------------------------
using namespace game;
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
///
///
/// Constructor
///
///
///-------------------------------------------------------------------------
AComponentBody::AComponentBody(const FPoint &position, const float angle)
{
    setPosition(position);
    setAngle(angle);
}
///-------------------------------------------------------------------------








 ///------------------------------------------------------------------------
///
/// <summary>
/// позиция
/// </summary>
///
///-------------------------------------------------------------------------
FPoint AComponentBody::position() const
{
    return mPosition;
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// добавить с которой будут двигатся объекты
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::applyForce(const FPoint &force)
{
    mForce += force;

    if (mBall)
    {
        mForceBall += force;
    }
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// добавить импульс для физтела
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: applyImpulse(const FPoint &impulse, const FPoint &contactVector)
{
    mVelocity += mShapeMassInverse * impulse;
    applyAngular(impulse, contactVector);

}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// устанавливаем объект встатический
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: setStatic()
{
    mBall = false;
    mStatic = true;
    mShapeInertia = 0.0f;
    mShapeInertiaInverse = 0.0f;
    mShapeMass = 0.0f;
    mShapeMassInverse = 0.0f;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// устанавливаем объект как шар
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: setBall()
{
    mBall = true;
    mStatic = false;

    if (const auto shape = findComponent<AComponentShape>())
    {
        shape->computeMass(1.0f);
    }
}
///-------------------------------------------------------------------------






 ///------------------------------------------------------------------------
///
/// <summary>
/// импульс для шара
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: applyBall(const FPoint &impulse)
{
    if (mBall)
    {
        mForceBall = impulse * mBallSpeed;
    }
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// импульс кручения закручивание объекта
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: applyAngular(const FPoint &impulse, const FPoint &contactVector)
{
    mAngularVelocity += mShapeInertiaInverse * math::cross(contactVector, impulse);
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// поворот 
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::angle() const
{
    const float degrees = (180.0f / math::PI) * mAngleRadians;

    return degrees;
}
///-------------------------------------------------------------------------








 ///------------------------------------------------------------------------
///
/// <summary>
/// установим угол
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::setAngle(const float degrees)
{
    //нужно перевести граудсы в радианы
    float radians = (math::PI / 180.0f) * degrees;

    setAngleRadian(radians);
}
///-------------------------------------------------------------------------



 ///------------------------------------------------------------------------
///
/// <summary>
/// установим угол
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::setAngleRadian(const float radians)
{
    if (const auto shape = findComponent<AComponentShape>())
    {
        shape->setAngleRadian(radians);
    }
    mAngleRadians = radians;
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// установка параметров
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: setMass( const float mass, const float inertia)
{
    if (mStatic)
    {
        mShapeInertia = 0.0f;
        mShapeInertiaInverse = 0.0f;
        mShapeMass = 0.0f;
        mShapeMassInverse = 0.0f;
        return;
    }

    mShapeMass = mass;
    mShapeMassInverse = (!math::isEqualFloat(mass, 0.0f)) ? 1.0f / mass : 0.0f;

    mShapeInertia = inertia;
    mShapeInertiaInverse = (!math::isEqualFloat(inertia, 0.0f)) ? 1.0f / inertia : 0.0f;
}
///-------------------------------------------------------------------------





///------------------------------------------------------------------------
///
/// <summary>
/// установим позицию новую
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::setPosition(const FPoint &pos)
{
    mPosition = pos;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// компоненты поменялись, что-то добавилось, что-то удалилось
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody :: changeComponents()
{
    if (const auto shape = findComponent<AComponentShape>())
    {
        mShapeType = shape->type();
        shape->setAngleRadian(mAngleRadians);
    }
}
///-------------------------------------------------------------------------





///------------------------------------------------------------------------
///
/// <summary>
/// возвратим текущий тип фигуры
/// </summary>
///
///-------------------------------------------------------------------------
EShapeType AComponentBody::shapeType()const
{
    return mShapeType;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// возвратим отскок
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::restitution() const
{
    return mRestitution;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// трение в статике
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::staticFriction() const
{
    return mStaticFriction;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// трение в движении
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::dynamicFriction() const
{
    return mDynamicFriction;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// текущая скорость
/// </summary>
///
///-------------------------------------------------------------------------
FPoint AComponentBody::velocity() const
{
    return mVelocity;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// текущая угловая скорость
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::angularVelocity() const
{
    return mAngularVelocity;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// масса поглащающая импульсы
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::massInverse() const
{
    return mShapeMassInverse;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// обратная инерция
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::inertiaInverse() const
{
    return mShapeInertiaInverse;
}
///-------------------------------------------------------------------------






 ///------------------------------------------------------------------------
///
/// <summary>
/// проверяет, объект динамический или нет
/// </summary>
///
///-------------------------------------------------------------------------
bool AComponentBody::isDynamic() const
{
    return !mStatic;
}
///-------------------------------------------------------------------------




 ///------------------------------------------------------------------------
///
/// <summary>
/// остановить движение
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::stopVelocity()
{
    mVelocity = { 0.0f, 0.0f };
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// установка скорости
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::setVelocity(const FPoint &value)
{
    mVelocity = value;
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// проверяет, это наш особенный объект мяч?
/// </summary>
///
///-------------------------------------------------------------------------
bool AComponentBody::isBall() const
{
    return mBall;
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// проверить, тело статичное или нет
/// </summary>
///
///-------------------------------------------------------------------------
bool AComponentBody::isStatic() const
{
    return mStatic;
}
///-------------------------------------------------------------------------




 ///------------------------------------------------------------------------
///
/// <summary>
/// угол наклона объекта в радианах
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::angleRadian() const
{
    return mAngleRadians;
}
///-------------------------------------------------------------------------






 ///------------------------------------------------------------------------
///
/// <summary>
/// удалить все силы
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::clearForce()
{
    mForce = { 0.0f, 0.0f };
    mTorque = 0.0f;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// подсчет действующих сил
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::integrateForces(const float time)
{
    if (mStatic)
    {
        return;
    }

    if (mBall)
    {
        //гравитация к шарам не действует
        const auto force = mForceBall + mForce;
        mVelocity += (force * mShapeMassInverse) * time;
        mAngularVelocity += mTorque * mShapeInertiaInverse * time;
    }   
    else
    {
        //обычне тела
        mVelocity += (mForce * mShapeMassInverse + settings::gravity) * time;
        mAngularVelocity += mTorque * mShapeInertiaInverse * time;
    }
}
///-------------------------------------------------------------------------







 ///------------------------------------------------------------------------
///
/// <summary>
/// подсчет скоростией и движения
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::integrateVelocity(const float time)
{
    if (mStatic)
    {
        //статические объекты недвигаются
        return;
    }

    const auto position = mPosition + mVelocity * time;
    const auto angle = mAngleRadians + mAngularVelocity * time;

    setAngleRadian(angle);

    mPosition = position;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// актуальня позиция
/// </summary>
///
///-------------------------------------------------------------------------
FPoint AComponentBody::positionRelevant() const
{
    return  mPosition;
}
///-------------------------------------------------------------------------



///------------------------------------------------------------------------
///
/// <summary>
/// ограничиваюшая рамка элемента
/// </summary>
///
///-------------------------------------------------------------------------
FPoint AComponentBody::boundingSize() const
{
    if (const auto shape = findComponent<AComponentShape>())
    {
        return shape->boundingSize();
    }
    return { 0.0f, 0.0f };
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// 
/// </summary>
///
///-------------------------------------------------------------------------
void AComponentBody::setBallSpeed(const float spd)
{
    mBallSpeed = spd;
}
///-------------------------------------------------------------------------





 ///------------------------------------------------------------------------
///
/// <summary>
/// текущая скорость шара
/// </summary>
///
///-------------------------------------------------------------------------
float AComponentBody::ballSpeed() const
{
    return mBallSpeed;
}